{"version":3,"sources":["deferred.js"],"names":["$","Deferred","func","tuples","Callbacks","once","memory","state","promise","always","deferred","done","arguments","fail","this","then","fns","defer","each","i","tuple","fn","isFunction","returned","apply","resolve","reject","progress","notify","context","values","obj","extend","list","stateString","add","disable","lock","fireWith","call","slice","Array","prototype","when","sub","progressValues","progressContexts","resolveContexts","resolveValues","len","length","remain","updateFn","ctx","val","value","notifyWith","resolveWith","Zepto"],"mappings":"CAMC,SAAUA,GAGT,QAASC,GAASC,GAChB,GAAIC,KAEI,UAAW,OAAQH,EAAEI,WAAWC,KAAK,EAAGC,OAAO,IAAK,aACpD,SAAU,OAAQN,EAAEI,WAAWC,KAAK,EAAGC,OAAO,IAAK,aACnD,SAAU,WAAYN,EAAEI,WAAWE,OAAO,MAE9CC,EAAQ,UACRC,GACED,MAAO,WACL,MAAOA,IAETE,OAAQ,WAEN,MADAC,GAASC,KAAKC,WAAWC,KAAKD,WACvBE,MAETC,KAAM,WACJ,GAAIC,GAAMJ,SACV,OAAOX,GAAS,SAASgB,GACvBjB,EAAEkB,KAAKf,EAAQ,SAASgB,EAAGC,GACzB,GAAIC,GAAKrB,EAAEsB,WAAWN,EAAIG,KAAOH,EAAIG,EACrCT,GAASU,EAAM,IAAI,WACjB,GAAIG,GAAWF,GAAMA,EAAGG,MAAMV,KAAMF,UACpC,IAAIW,GAAYvB,EAAEsB,WAAWC,EAASf,SACpCe,EAASf,UACNG,KAAKM,EAAMQ,SACXZ,KAAKI,EAAMS,QACXC,SAASV,EAAMW,YACb,CACL,GAAIC,GAAUf,OAASN,EAAUS,EAAMT,UAAYM,KAC/CgB,EAAST,GAAME,GAAYX,SAC/BK,GAAMG,EAAM,GAAK,QAAQS,EAASC,QAIxCd,EAAM,OACLR,WAGLA,QAAS,SAASuB,GAChB,MAAc,OAAPA,EAAc/B,EAAEgC,OAAQD,EAAKvB,GAAYA,IAGpDE,IAuBJ,OArBAV,GAAEkB,KAAKf,EAAQ,SAASgB,EAAGC,GACzB,GAAIa,GAAOb,EAAM,GACbc,EAAcd,EAAM,EAExBZ,GAAQY,EAAM,IAAMa,EAAKE,IAErBD,GACFD,EAAKE,IAAI,WACP5B,EAAQ2B,GACP/B,EAAS,EAAFgB,GAAK,GAAGiB,QAASjC,EAAO,GAAG,GAAGkC,MAG1C3B,EAASU,EAAM,IAAM,WAEnB,MADAV,GAASU,EAAM,GAAK,QAAQN,OAASJ,EAAWF,EAAUM,KAAMF,WACzDE,MAETJ,EAASU,EAAM,GAAK,QAAUa,EAAKK,WAGrC9B,EAAQA,QAAQE,GACZR,GAAMA,EAAKqC,KAAK7B,EAAUA,GACvBA,EApET,GAAI8B,GAAQC,MAAMC,UAAUF,KAuE5BxC,GAAE2C,KAAO,SAASC,GAChB,GAKIC,GAAgBC,EAAkBC,EALlCC,EAAgBR,EAAMD,KAAK3B,WAC3BqC,EAAMD,EAAcE,OACpB/B,EAAI,EACJgC,EAAiB,IAARF,GAAcL,GAAO5C,EAAEsB,WAAWsB,EAAIpC,SAAYyC,EAAM,EACjEvC,EAAsB,IAAXyC,EAAeP,EAAM3C,IAEhCmD,EAAW,SAASjC,EAAGkC,EAAKC,GAC1B,MAAO,UAASC,GACdF,EAAIlC,GAAKL,KACTwC,EAAInC,GAAKP,UAAUsC,OAAS,EAAIV,EAAMD,KAAK3B,WAAa2C,EACpDD,IAAQT,EACVnC,EAAS8C,WAAWH,EAAKC,KACZH,GACbzC,EAAS+C,YAAYJ,EAAKC,IAKpC,IAAIL,EAAM,EAIR,IAHAJ,EAAiB,GAAIJ,OAAMQ,GAC3BH,EAAmB,GAAIL,OAAMQ,GAC7BF,EAAkB,GAAIN,OAAMQ,GAChBA,EAAJ9B,IAAWA,EACb6B,EAAc7B,IAAMnB,EAAEsB,WAAW0B,EAAc7B,GAAGX,SACpDwC,EAAc7B,GAAGX,UACdG,KAAKyC,EAASjC,EAAG4B,EAAiBC,IAClCnC,KAAKH,EAASgB,QACdC,SAASyB,EAASjC,EAAG2B,EAAkBD,MAExCM,CAKR,OADKA,IAAQzC,EAAS+C,YAAYV,EAAiBC,GAC5CtC,EAASF,WAGlBR,EAAEC,SAAWA,GACZyD","file":"deferred.js","sourcesContent":["//     Zepto.js\n//     (c) 2010-2014 Thomas Fuchs\n//     Zepto.js may be freely distributed under the MIT license.\n//\n//     Some code (c) 2005, 2013 jQuery Foundation, Inc. and other contributors\n\n;(function($){\n  var slice = Array.prototype.slice\n\n  function Deferred(func) {\n    var tuples = [\n          // action, add listener, listener list, final state\n          [ \"resolve\", \"done\", $.Callbacks({once:1, memory:1}), \"resolved\" ],\n          [ \"reject\", \"fail\", $.Callbacks({once:1, memory:1}), \"rejected\" ],\n          [ \"notify\", \"progress\", $.Callbacks({memory:1}) ]\n        ],\n        state = \"pending\",\n        promise = {\n          state: function() {\n            return state\n          },\n          always: function() {\n            deferred.done(arguments).fail(arguments)\n            return this\n          },\n          then: function(/* fnDone [, fnFailed [, fnProgress]] */) {\n            var fns = arguments\n            return Deferred(function(defer){\n              $.each(tuples, function(i, tuple){\n                var fn = $.isFunction(fns[i]) && fns[i]\n                deferred[tuple[1]](function(){\n                  var returned = fn && fn.apply(this, arguments)\n                  if (returned && $.isFunction(returned.promise)) {\n                    returned.promise()\n                      .done(defer.resolve)\n                      .fail(defer.reject)\n                      .progress(defer.notify)\n                  } else {\n                    var context = this === promise ? defer.promise() : this,\n                        values = fn ? [returned] : arguments\n                    defer[tuple[0] + \"With\"](context, values)\n                  }\n                })\n              })\n              fns = null\n            }).promise()\n          },\n\n          promise: function(obj) {\n            return obj != null ? $.extend( obj, promise ) : promise\n          }\n        },\n        deferred = {}\n\n    $.each(tuples, function(i, tuple){\n      var list = tuple[2],\n          stateString = tuple[3]\n\n      promise[tuple[1]] = list.add\n\n      if (stateString) {\n        list.add(function(){\n          state = stateString\n        }, tuples[i^1][2].disable, tuples[2][2].lock)\n      }\n\n      deferred[tuple[0]] = function(){\n        deferred[tuple[0] + \"With\"](this === deferred ? promise : this, arguments)\n        return this\n      }\n      deferred[tuple[0] + \"With\"] = list.fireWith\n    })\n\n    promise.promise(deferred)\n    if (func) func.call(deferred, deferred)\n    return deferred\n  }\n\n  $.when = function(sub) {\n    var resolveValues = slice.call(arguments),\n        len = resolveValues.length,\n        i = 0,\n        remain = len !== 1 || (sub && $.isFunction(sub.promise)) ? len : 0,\n        deferred = remain === 1 ? sub : Deferred(),\n        progressValues, progressContexts, resolveContexts,\n        updateFn = function(i, ctx, val){\n          return function(value){\n            ctx[i] = this\n            val[i] = arguments.length > 1 ? slice.call(arguments) : value\n            if (val === progressValues) {\n              deferred.notifyWith(ctx, val)\n            } else if (!(--remain)) {\n              deferred.resolveWith(ctx, val)\n            }\n          }\n        }\n\n    if (len > 1) {\n      progressValues = new Array(len)\n      progressContexts = new Array(len)\n      resolveContexts = new Array(len)\n      for ( ; i < len; ++i ) {\n        if (resolveValues[i] && $.isFunction(resolveValues[i].promise)) {\n          resolveValues[i].promise()\n            .done(updateFn(i, resolveContexts, resolveValues))\n            .fail(deferred.reject)\n            .progress(updateFn(i, progressContexts, progressValues))\n        } else {\n          --remain\n        }\n      }\n    }\n    if (!remain) deferred.resolveWith(resolveContexts, resolveValues)\n    return deferred.promise()\n  }\n\n  $.Deferred = Deferred\n})(Zepto)\n"],"sourceRoot":"/source/"}